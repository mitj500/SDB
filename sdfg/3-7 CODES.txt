




EXP 3: Design a Lexical analyser for a language whose grammar(input already in code)


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#define MAX_KEYWORDS 32
#define MAX_IDENTIFIERS 100
#define MAX_PUNCTUATIONS 20
#define MAX_SYMBOLS 100
// Function prototypes
void processToken(char token[]);
char keywords[MAX_KEYWORDS][20] = {"int", "float", "if", "else", "while", "for",
"return"}; // Example keywords
char identifiers[MAX_IDENTIFIERS][20];
char punctuations[MAX_PUNCTUATIONS][2]; // Assuming single character
punctuations char symbols[MAX_SYMBOLS][2]; // Assuming single character symbols
int keywordCount = 0;
int identifierCount = 0;
int punctuationCount = 0;

int symbolCount = 0;
int main()
{
FILE *sourceFile;
char filename[100], c;
char token[100] = "";
int i;
printf("Enter the filename: ");
scanf("%s", filename);
sourceFile = fopen(filename, "r");
if (sourceFile == NULL)
{
printf("File not found or error in opening the file.\n"); exit(0);
}
while ((c = fgetc(sourceFile)) != EOF)
{
if (isalnum(c) || c == '.')
{
strncat(token, &c, 1);
}
else
{
if (strlen(token) > 0)
{
processToken(token);
memset(token, 0, sizeof(token));

}
if (c == ' ' || c == '\n' || c == '\t')
{
continue; // Skip whitespace characters

}
else if (ispunct(c))
{
punctuations[punctuationCount][0] = c;
punctuations[punctuationCount][1] = '\0';
punctuationCount++;

}
else {
symbols[symbolCount][0] = c;
symbols[symbolCount][1] = '\0';
symbolCount++;
}
}
}

fclose(sourceFile);
printf("Keywords:\n");
for (i = 0; i < keywordCount; i++)
{
printf("%s\n", keywords[i]);
}
printf("\nIdentifiers:\n");
for (i = 0; i < identifierCount; i++)
{
printf("%s\n", identifiers[i]);
}
printf("\nPunctuations:\n");
for (i = 0; i < punctuationCount; i++)
{
printf("%s\n", punctuations[i]);
}
printf("\nSymbols:\n");
for (i = 0; i < symbolCount; i++)
{
printf("%s\n", symbols[i]);
}
return 0;
}
void processToken(char token[])
{
int i;
for (i = 0; i < MAX_KEYWORDS; i++)
{
if (strcmp(token, keywords[i]) == 0)
{
return;
}
}
for (i = 0; i < identifierCount; i++)
{
if (strcmp(token, identifiers[i]) == 0)
{
return;
}
}
strcpy(identifiers[identifierCount], token);
identifierCount++;
}

src.txt
#include int main()
{
int x = 5;
float y = 3.14;
printf("Hello, world!\n");
return 0;
}


##OUTPUT:

note: store src.txt and the code file in same folder
Enter the filename: src.txt
remaining output will be displayed





EXP 4: Implementation of Operator Precedence Parser


#include<stdio.h>
#include<stdlib.h>
#include<string.h>
char *input;
int i=0;
char lasthandle[6],stack[50],handles[][5]={")E(","E*E","E+E","i","E^E"};
int top=0, l;
char prec[9][9]={
/* + */ '>', '>','<','<','<','<','<','>','>',
/* - */ '>', '>','<','<','<','<','<','>','>',
/* * */ '>', '>','>','>','<','<','<','>','>',
/* / */ '>', '>','>','>','<','<','<','>','>',
/* ^ */ '>', '>','>','>','<','<','<','>','>',
/* i */ '>', '>','>','>','>','e','e','>','>',
/* ( */ '<', '<','<','<','<','<','<','>','e',
/* ) */ '>', '>','>','>','>','e','e','>','>',
/* $ */ '<', '<','<','<','<','<','<','<','>',
};

int getindex(char c)
{
	switch(c)
	{
	case '+':return 0;
	case '-':return 1;
	case '*':return 2;
	case '/':return 3;
	case '^':return 4;
	case 'i':return 5;
	case '(':return 6;
	case ')':return 7;
	case '$':return 8;
	}
}
int shift()
{
	stack[++top]=*(input+i++);
	stack[top+1]='\0';
}
int reduce()
{
	int i,len,found,t;
	for(i=0;i<5;i++)//selecting handles
	{
		len=strlen(handles[i]);
		if(stack[top]==handles[i][0]&&top+1>=len)
		{
			found=1;
			for(t=0;t<len;t++)
			{
			if(stack[top-t]!=handles[i][t])
			{
				found=0;
				break;
			}
		}
		if(found==1)
		{
			stack[top-t+1]='E';
			top=top-t+1;

			strcpy(lasthandle,handles[i]);
			stack[top+1]='\0';
			return 1;
		}
	}
}
return 0;
}
void dispstack()
{
int j;
for(j=0;j<=top;j++)
printf("%c",stack[j]);
}
void dispinput()
{
int j;
for(j=i;j<l;j++)
printf("%c",*(input+j));
}
void main()
{
int j;
input=(char*)malloc(50*sizeof(char));
printf("\nEnter the string\n");
scanf("%s",input);
input=strcat(input,"$");
l=strlen(input);
strcpy(stack,"$");
printf("\nSTACK\tINPUT\tACTION");
while(i<=l)
{
shift();
printf("\n");
dispstack();
printf("\t");
dispinput();
printf("\tShift");
if(prec[getindex(stack[top])][getindex(input[i])]=='>')

{
while(reduce())
{
printf("\n");
dispstack();
printf("\t");
dispinput();
printf("\tReduced: E->%s",lasthandle);
}
}
}
if(strcmp(stack,"$E$")==0)
printf("\nAccepted;");
else
{
printf("\nNot Accepted;");
}




EXP 5: implementation of shift reduce parser (input already given in code)


#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int z = 0, i = 0, j = 0, c = 0;
char a[16], ac[20], stk[15], act[10];
void check()
{

	strcpy(ac,"REDUCE TO E -> ");

	for(z = 0; z < c; z++)
	{

		if(stk[z] == '4')

			{
				printf("%s4", ac);
				stk[z] = 'E';
				stk[z + 1] = '\0';

				printf("\n$%s\t%s$\t", stk, a);
			}
	}
	for(z = 0; z < c - 2; z++)
	{

		if(stk[z] == '2' && stk[z + 1] == 'E' && stk[z + 2] == '2')
		{
			printf("%s2E2", ac);
			stk[z] = 'E';
			stk[z + 1] = '\0';
			stk[z + 2] = '\0';
			printf("\n$%s\t%s$\t", stk, a);
			i = i - 2;
		}
	}
	for(z=0; z<c-2; z++)
	{
		if(stk[z] == '3' && stk[z + 1] == 'E' && stk[z + 2] == '3')
		{
			printf("%s3E3", ac);
			stk[z]='E';
			stk[z + 1]='\0';
			stk[z + 1]='\0';
			printf("\n$%s\t%s$\t", stk, a);
			i = i - 2;
		}
	}
	return ;
}

int main()
{

	printf("GRAMMAR is -\nE->2E2 \nE->3E3 \nE->4\n");
	strcpy(a,"32423");
	c=strlen(a);
	strcpy(act,"SHIFT");

	printf("\nstack \t input \t action");
	printf("\n$\t%s$\t", a);
	for(i = 0; j < c; i++, j++)
		{
			printf("%s", act);
			stk[i] = a[j];
			stk[i + 1] = '\0';

			a[j]=' ';

			printf("\n$%s\t%s$\t", stk, a);
			check();
		}
	check();
	if(stk[0] == 'E' && stk[1] == '\0')
		{
			printf("Accept\n");
		}		
	else 
		{
			printf("Reject\n");

		}




EXP 6: code optimization techniques (input already given in code)


#include <stdio.h>
#include <time.h>
#define MAX 100
int cache[MAX] = {0};

int factorial_unoptimized(int n) {
if (n <= 1) {
return 1;
} else {
return n * factorial_unoptimized(n - 1);
}
}


int factorial_optimized_memoization(int n, int cache[]) {
if (n <= 1) {
return 1;
} else if (cache[n] != 0) {
return cache[n];

} else {
cache[n] = n * factorial_optimized_memoization(n - 1, cache);
return cache[n];
}
}

int main() {
clock_t start, end;
double cpu_time_used_unoptimized = 0, cpu_time_used_optimized = 0;

int num = 30;
int iterations = 1000000;
// Original unoptimized version
for (int i = 0; i < iterations; i++) {
start = clock();
int result1 = factorial_unoptimized(num);
end = clock();
cpu_time_used_unoptimized += ((double) (end - start)) / CLOCKS_PER_SEC;
}
printf("Unoptimized - Factorial of %d is: %d\n", num, factorial_unoptimized(num));
// Optimized version with memoization
for (int i = 0; i < iterations; i++) {
start = clock();
// Initialize cache array
int result2 = factorial_optimized_memoization(num, cache);
end = clock();
cpu_time_used_optimized += ((double) (end - start)) / CLOCKS_PER_SEC;
}
printf("Optimized (with memoization) - Factorial of %d is: %d\n", num,
factorial_optimized_memoization(num, cache));
// Print average CPU time used for both versions
printf("Average unoptimized CPU time used: %.10lf seconds\n",
cpu_time_used_unoptimized / iterations);
printf("Average optimized CPU time used: %.10lf seconds\n",
cpu_time_used_optimized / iterations);
return 0;
}


##OUTPUT

unoptimized: factorial of 30 is xyz
optimized: factorial of 30 is xyz
average unoptimized CPU time used is : xyz
average unoptimized CPU time used is : xyz

note: avg. unoptimized time > avg. optimized time




EXP 7: lex and yacc (input by user: 2*(4+5-1))


lexer.l :

%
{
#include <stdio.h>
#include <stdlib.h>
#include "y.tab.h"
%}
%%
[0-9]+ { yylval = atoi(yytext);
return NUM;
}
[-+*/\(\)\n]
{
return yytext[0];
}
[ \t] ; // Ignore whitespace .
{
fprintf(stderr, "Error: Invalid character %s\n", yytext); }
%% int yywrap()
{
return 1;
}

parser.y:

%{
#include int yylex();
void yyerror(const char *);
%}
%token NUM %% S : E '\n'
{
printf("The value of the expression is %d\n", $1);
}
| E { printf("The value of the expression is %d\n", $1); }
;
E : E '+' T { $$ = $1 + $3; }
| E '-' T { $$ = $1 - $3; }
| T { $$ = $1; }
;
T : T '*' F { $$ = $1 * $3; }
| T '/' F { $$ = $1 / $3; }
| F { $$ = $1; }
;
F : '(' E ')' { $$ = $2; }
| NUM { $$ = $1; }
;
%%
void yyerror(const char *s)
{
fprintf(stderr, "Error: %s\n", s);
}

main.c:
#include <stdio.h>
extern int yyparse();
int main()
{
yyparse();
return 0;
}

##OUTPUT

flex lexer.l
yacc -parser.y
gcc lex.yy.c y.tab.c main.c -o parser -ll
2*(4+5-1)
The value of the expression is 16